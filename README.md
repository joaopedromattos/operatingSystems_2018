# Operating Systems assignment - October 2018
## Porque há necessidade de um escalonador?
    A necessidade de um escalonador advém do fato de que, de acordo com o tipo de sistema operacional e com a organização dos múltiplos processadores, diferentes problemas de sincronia, de overhead e de consistência da cache podem acontecer com um sistema computacional de várias CPUs, e são essas questões que um escalonador de processos se propõe a resolver. 
### Funcionamento básico
	Em um sistema simples, de um único processador, o escalonador de processos atua em cima a uma estrutura muitas vezes análoga a uma fila de prioridades, ou heap. Há diferentes critérios para designar a prioridade: o primeiro processo a chegar é atendido primeiro (FCFS), ou aquele com o tempo mais curto de uso de CPU (SJF), nível de criticidade ou até mesmo são designados um momento específico de execução dentro de um ciclo (Round Robin). 
    Porém, em sistemas de multicomputadores é necessário mais um nível de gerenciamento, onde os processos devem ser distribuídos de modo a evitar ao máximo a ociosidade e a sobrecarga. Para isso existem algumas estratégias como tratar os diversos processadores como um grafo para minimizar o tráfego de rede ou fazer com que os processadores busquem por trabalho/processadores livres.
## Abordagem do problema
Nos deparamos com um exercício que julgamos bastante interessante implementar na sessão de problemas do oitavo capítulo da quarta edição de Sistemas Operacionais Modernos (TANENBAUM, Andrew S.):
>“37. Escreva um programa que implemente os algoritmos de balanceamento de carga iniciados pelo emissor e iniciados pelo receptor descritos na Seção 8.2. 
>Os algoritmos devem tomar como entrada uma lista de tarefas recentemente criadas especificadas como (creating_processor, start_time, required_CPU_time) em que o creating_processor é o número da CPU que criou a tarefa, o start_time é o tempo no qual a tarefa foi criada e o required_CPU_time é a quantidade de tempo da CPU de que a tarefa precisa para ser completada (especificada em segundos).
>Presuma que um nó está sobrecarregado quando ele tem uma tarefa e uma segunda tarefa é criada. Presuma que um nó está subcarregado quando ele não tem tarefa alguma. 
>Imprima o número de mensagens de sondagem enviadas por ambos os algoritmos sob cargas de trabalho pesadas e leves. Também imprima o número máximo e mínimo de sondagens enviadas por qualquer hospedeiro e recebidas por qualquer hospedeiro. 
>Para criar as cargas de trabalho, escreva dois geradores de cargas de trabalho. O primeiro deve simular uma carga de trabalho pesada, gerando, na média, N tarefas a cada AJL segundos, em que AJL é duração média de tarefa e N é o número de processadores. Durações de tarefas podem ser uma mistura de tarefas longas e curtas, mas a duração de trabalho médio deve ser AJL. As tarefas devem ser criadas (colocadas) aleatoriamente através de todos os processadores. O segundo gerador deve simular uma carga leve, gerando aleatoriamente N/3 tarefas a cada AJL segundos. Simule com outras configurações de parâmetros para os geradores de carga de trabalho e veja como elas afetam o número de mensagens de sondagem.”
Um grupo implementará um algoritmo de balanceamento de carga iniciado pelo emissor e o outro, iniciado pelo receptor. No primeiro, um processo é executado no nó em que foi criado, desde que o nó não esteja sobrecarregado. Se estiver, começa a mandar mensagens para outros nós, buscando um com capacidade para executar o processo. Caso não encontre, espera o processo atual terminar e executa-o ele mesmo.No segundo algoritmo, quando um nó termina um processo ele escolhe outro para o qual perguntará se há algum processo em espera e entra em estado ocioso somente se após buscar em n nós não encontra trabalho algum.